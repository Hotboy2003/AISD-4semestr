# Открытие файла с матрицей смежности
with open('graph.txt', 'r') as file:
    # Чтение матрицы смежности из файла
    matrix = [[int(num) for num in line.split()] for line in file]

"""
Первым шагом программа открывает файл с матрицей смежности. Он открывается в режиме чтения ('r'). В
 строке ниже происходит чтение матрицы смежности из файла, преобразование строк в числа с помощью функции `int`, 
 а затем запись чисел в матрицу `matrix`. 
"""
# Размер матрицы
n = len(matrix)

"""
Далее определяем размер матрицы по количеству элементов в первой строке матрицы. 
Текущий код предполагает, что матрица является квадратной.
"""

# Список посещенных вершин
visited = [False] * n

# Список компонент связности
components = []

"""
Затем создаются два списка: `visited` для отслеживания посещённых вершин и `components` для хранения компонент связности.
"""

def bfs(start_node, graph, visited, component):
    # Очередь для обхода в ширину
    queue = [start_node]
    visited[start_node] = True

    while queue:
        # Извлечение вершины из очереди
        node = queue.pop(0)
        component.append(node)

        # Перебор смежных вершин
        for i in range(n):
            if graph[node][i] and not visited[i]:
                visited[i] = True
                queue.append(i)

"""
Далее идет определение функции обхода графа в ширину (`bfs`). Она инициализирует список смежности `queue`, 
помечает стартовую вершину `start_node` как посещённую и начинает обход графа. Поскольку в этом алгоритме 
мы будем пользоваться функцией `pop(0)` для извлечения вершин из очереди `queue` в голове списка, 
то понадобится список, который бы поддерживал такую работу.
Цикл `while` пока не закончится список смежности `queue`. Каждый раз на вершину добавляется одна смежная непосещённая вершина. 
Находятся все смежные вершины, помечаются как посещённые и добавляются в список `queue`.
"""

# Обход графа в ширину
for i in range(n):
    if not visited[i]:
        component = []
        bfs(i, matrix, visited, component)
        components.append(component)

"""
Далее мы начинаем обход графа в ширину с каждой вершины `i`, которую ещё не посещали. Для каждой не посещённой вершины создаётся 
список `component` для хранения текущей компоненты связности, и вызывается функция `bfs(start_vertex, graph, visited, component)`.
"""

# Запись результата в файл
with open('output.txt', 'w') as file:
    file.write(f'Количество компонент связности: {len(components)}\n\n')
    for i, component in enumerate(components):
        file.write(f'Компонента связности {i + 1}: {component}\n')
